/* 
 * File:   ubench.cpp
 * Author: tabrown
 *
 * An array-based microbenchmark for k-CAS
 * 
 * Created on June 23, 2016, 6:45 PM
 */

#include <cstdlib>
#include <chrono>
#include <time.h>
#include <pthread.h>
#include <math.h>
#include <algorithm>
#include "../include/tsc.h"
#include <random.h>
#include <debugprinting.h>
#include "../globals.h"
#include "../globals_extern.h"
#include <debugcounter.h>
#ifdef THROWAWAY
    #include "kcas_throwaway.h"
#else
    #include "kcas_reuse.h"
#endif
#include <record_manager.h>
#include <binding.h>
#include <papi_util_impl.h>
#include <set>
//#include <avcall.h>
#include <memusage.h>
using namespace std;

//extern __thread long long maxAllocatedBytes;

//#define RECORD_HISTOGRAM
int *histogram;

volatile long long memoryFootprintBefore = 0;
volatile long long memoryFootprintAfter = 0;
volatile long long memoryFootprintPeak = 0;

#ifndef KCAS_MAXK
#error Must define KCAS_MAXK
#endif

#ifndef KCAS_MAXTHREADS
#error Must define KCAS_MAXTHREADS
#endif

#ifndef RECLAIM
#error Must define RECLAIM, e.g., debra
#endif

#ifndef POOL
#error Must defile POOL, e.g., perthread_and_shared
#endif

#define CAT(x, y) x ## y
#define CAT_RECLAIM(x) CAT(reclaimer_, x)
#define CAT_POOL(x) CAT(pool_, x)

typedef kcasdesc_t<KCAS_MAXK, KCAS_MAXTHREADS> DescriptorType;
typedef rdcssdesc_t DescriptorType2;

//typedef reclaimer_debra<casword_t> Reclaim;
//typedef reclaimer_hazardptr<casword_t> Reclaim;
//typedef reclaimer_none<casword_t> Reclaim;

typedef allocator_new<casword_t> Alloc;
//typedef pool_perthread_and_shared<casword_t> Pool;
//typedef pool_none<casword_t> Pool;

typedef CAT_RECLAIM(RECLAIM)<casword_t> Reclaim;
typedef CAT_POOL(POOL)<casword_t> Pool;

typedef record_manager<Reclaim, Alloc, Pool, DescriptorType, DescriptorType2> RecManagerType;
typedef kcasProvider<KCAS_MAXK,KCAS_MAXTHREADS,RecManagerType> KCASProviderType;

#define stringify(x) #x
#define dbg(x) " "<<stringify(x)<<"="<<x

template <class RecManager>
class dataStructure {
public:
    KCASProviderType prov;
    casword_t *data;
    const int size;
    debugCounter *successful;
    debugCounter *totalOps;

    dataStructure(const int numProcesses, const int _size) : size(_size) {
        data = new casword_t[_size];
        for (int i=0;i<_size;++i) {
            prov.writeVal(&data[i], 0);
        }
        successful = new debugCounter(numProcesses);
        totalOps = new debugCounter(numProcesses);
    }
    ~dataStructure() {
        delete[] data;
        delete successful;
        delete totalOps;
    }
    void initThread(const int tid) {
        prov.initThread(tid);
    }
    bool atomicIncrementK(const int tid, Random * const rng) {
        // generate random indices to perform kcas on
        int ix[KCAS_MAXK+1];
        
#define DIST_UNIFORM_SORT
#if defined(DIST_EXPONENTIAL)
        {
            int lastRand;
            int temp;
            lastRand = -1;
            for (int i=0;i<KCAS_MAXK;++i) {
                temp = rng->nextNatural(MAXKEY - (lastRand+1) - (KCAS_MAXK-i-1)) + lastRand + 1;
                lastRand = temp;
                ix[i] = temp;
            }
        }
#elif defined(DIST_UNIFORM_SORT)
        {
            int maxval = -1;
            for (int i=0;i<KCAS_MAXK+1;++i) {
                ix[i] = rng->nextNatural() & 0x7fffffff;
                if (ix[i] > maxval) maxval = ix[i];
            }
            sort(ix, ix + KCAS_MAXK+1);
            int maxover = 0;
            for (int i=0;i<KCAS_MAXK;++i) {
                ix[i] = (int)((double) ix[i] * MAXKEY / maxval);
                if (ix>0 && ix[i] <= ix[i-1]) ix[i] = ix[i-1]+1;
                if (ix[i] - (MAXKEY-1) > maxover) maxover = ix[i] - (MAXKEY-1);
            }
            if (maxover > 0) {
                //cout<<"maxover was "<<maxover<<endl;
                if (ix[0] - maxover >= 0) ix[0] -= maxover;
                else ix[0] = 0;
                
                for (int i=1;i<KCAS_MAXK;++i) {
                    if (ix[i] - maxover > ix[i-1]) ix[i] -= maxover;
                    else ix[i] = ix[i-1]+1;
                }
            }
        }
#endif
        
//        cout<<"ix =";
//        for (int i=0;i<KCAS_MAXK;++i) {
//            cout<<" "<<ix[i];
//        }
//        cout<<endl;
        
#ifndef NDEBUG
        // perform validation on indices generated by the above
        for (int i=0;i<KCAS_MAXK;++i) {
#ifdef RECORD_HISTOGRAM
            if (tid == 0) ++histogram[ix[i]];
#endif
            if (ix[i] < 0) { cout<<"FAILURE: ix["<<i<<"]="<<ix[i]<<endl; exit(-1); }
            if (ix[i] >= MAXKEY) { cout<<"FAILURE: ix["<<i<<"]="<<ix[i]<<endl; exit(-1); }
            if (i>0 && ix[i] <= ix[i-1]) { cout<<"FAILURE: ix["<<i-1<<"]="<<ix[i-1]<<" and ix["<<i<<"]="<<ix[i]<<endl; exit(-1); }
        }
//        return true;
#endif
        
        // create a new kcas descriptor
        DescriptorType *ptr = prov.allocateKcasDesc(tid);
        ptr->numEntries = KCAS_MAXK;
        for (int i=0;i<ptr->numEntries;++i) {
            casword_t* addr = &data[ix[i]];
            casword_t oldval = prov.readVal(tid, &data[ix[i]]);
            casword_t newval = oldval+1;
            ptr->entries[i].addr = addr;
            ptr->entries[i].oldval = oldval<<KCAS_LEFTSHIFT;
            ptr->entries[i].newval = newval<<KCAS_LEFTSHIFT;
        }
        
        // invoke the actual kcas (which will clean up the kcas descriptor eventually)
        return prov.kcas(tid, ptr);

//        // use special library calls to perform a varargs call
//        // from arguments that we identify incrementally in a loop
//        // note: we are essentially manually building the stack frame for the call
//        int result;
//        av_alist alist;
//        av_start_int(alist, KCASProviderType::kcas, &result);
////        cout<<"pushing args"<<dbg(this)<<dbg(tid)<<" KCAS_MAXK="<<KCAS_MAXK<<endl;
//        av_ptr(alist, KCASProviderType*, &prov);
//        av_int(alist, tid);
//        av_int(alist, KCAS_MAXK);
//        casword_t fieldType = KCASProviderType::FIELD_TYPE_VALUE;
//        for (int i=0;i<KCAS_MAXK;++i) {
//            casword_t oldval = prov.readVal(tid, &data[ix[i]]);
////            cout<<"iteration"<<dbg(i)<<dbg(ix[i])<<" pushing args"<<dbg(&data[ix[i]])<<dbg(oldval)<<dbg(oldval+1)<<dbg(fieldType)<<endl;
//            av_ptr(alist, casword_t*, &data[ix[i]]);
//            av_ptr(alist, casword_t, oldval);
//            av_ptr(alist, casword_t, oldval+1);
//            av_ptr(alist, casword_t, fieldType);
//        }
////        cout<<"invoking avcall"<<endl;
//        // PERFORM THE ACTUAL KCAS (note: this macro calls kcas())
//        av_call(alist);
//        return result;
        
//        casword_t oldval1 = prov.readVal(tid, &data[ix[0]]);
//        casword_t newval1 = oldval1+1;
//        casword_t oldval2 = prov.readVal(tid, &data[ix[1]]);
//        casword_t newval2 = oldval2+1;
//        bool result = prov.kcas(tid, 2
//            , &data[ix[0]], oldval1, newval1, KCASProviderType::FIELD_TYPE_VALUE
//            , &data[ix[1]], oldval2, newval2, KCASProviderType::FIELD_TYPE_VALUE);
//        return result;
    }
    long long getTotal(const int tidForReading) {
        long long result = 0;
        for (int i=0;i<size;++i) {
            result += data[i]; //prov.readVal(tidForReading, &data[i]);
        }
        //return result;
        return result>>KCAS_LEFTSHIFT;
    }
};

dataStructure<RecManagerType> *ds; // TODO: allocate and delete
static Random rngs[MAX_TID_POW2*PREFETCH_SIZE_WORDS]; // create per-thread random number generators (padded to avoid false sharing)

// variables used in the concurrent test
chrono::time_point<chrono::high_resolution_clock> startTime;
chrono::time_point<chrono::high_resolution_clock> endTime;
long elapsedMillis;
bool start = false;
bool done = false;
atomic_int running; // number of threads that are running

template <class RecManager>
void *thread_timed(void *_id) {
    const int OPS_BETWEEN_TIME_CHECKS = 500;
    int tid = *((int*) _id);
    binding_bindThread(tid, LOGICAL_PROCESSORS);
    Random *rng = &rngs[tid*PREFETCH_SIZE_WORDS];

    ds->initThread(tid);
    papi_create_eventset(tid);
    running.fetch_add(1);
    __sync_synchronize();
    while (!start) { __sync_synchronize(); TRACE COUTATOMICTID("waiting to start"<<endl); } // wait to start
    papi_start_counters(tid);
    int cnt = 0;
    while (!done) {
        if (((++cnt) % OPS_BETWEEN_TIME_CHECKS) == 0) {
            chrono::time_point<chrono::high_resolution_clock> __endTime = chrono::high_resolution_clock::now();
            if (chrono::duration_cast<chrono::milliseconds>(__endTime-startTime).count() >= MILLIS_TO_RUN) {
                done = true;
                __sync_synchronize();
                break;
            }
        }
        
        VERBOSE if (cnt&&((cnt % 1000000) == 0)) COUTATOMICTID("op# "<<cnt<<endl);
//        int ix1 = rng->nextNatural(MAXKEY);
//        int ix2 = rng->nextNatural(MAXKEY);
//        if (ix1 == ix2) {
//            ix2 = (ix1 + 1) % MAXKEY;
//        }
        if (ds->atomicIncrementK(tid, rng)) {
            ds->successful->inc(tid);
        }
        ds->totalOps->inc(tid);
        
#ifdef DELAY_CYCLES
        // insert delay before next atomicIncrementK, to simulate external work
        wait_cycles(read_tsc() + DELAY_CYCLES);
#endif
    }
    papi_stop_counters(tid);
//    __sync_fetch_and_add(&memoryFootprintPeak, maxAllocatedBytes);
    running.fetch_add(-1);
//    COUTATOMICTID("terminated"<<endl);
    return NULL;
}

template <class RecManager>
void printOutput();

template <class RecManager>
void trial() {
    // get random number generator seeded with time
    // we use this rng to seed per-thread rng's that use a different algorithm
    srand(time(NULL));

    papi_init_program(TOTAL_THREADS);
    
    // create threads
    pthread_t *threads[TOTAL_THREADS];
    int ids[TOTAL_THREADS];
    for (int i=0;i<TOTAL_THREADS;++i) {
        threads[i] = new pthread_t;
        ids[i] = i;
        rngs[i*PREFETCH_SIZE_WORDS].setSeed(rand());
    }
    
    // amount of time for main thread to wait for children threads
    timespec tsExpected;
    tsExpected.tv_sec = MILLIS_TO_RUN / 1000;
    tsExpected.tv_nsec = (MILLIS_TO_RUN % 1000) * ((__syscall_slong_t) 1000000);
    // short nap
    timespec tsNap;
    tsNap.tv_sec = 0;
    tsNap.tv_nsec = 10000000; // 10ms

    // start all threads
    for (int i=0;i<TOTAL_THREADS;++i) {
        if (pthread_create(threads[i], NULL, thread_timed<RecManager>, &ids[i])) {
            cerr<<"ERROR: could not create thread"<<endl;
            exit(-1);
        }
    }

    while (running.load() < TOTAL_THREADS) {
        TRACE COUTATOMIC("main thread: waiting for threads to START running="<<running.load()<<endl);
    } // wait for all threads to be ready

//    memoryFootprintBefore = getCurrentRSS();

    COUTATOMIC("main thread: starting timer..."<<endl);
    startTime = chrono::high_resolution_clock::now();
    __sync_synchronize();
    start = true;

    // replace pthread_join with sleeping, and kill if we run too long
    // method: sleep for the desired time + a small epsilon,
    //      then check "running.load()" to see if we're done.
    //      if not, loop and sleep in small increments for up to 1s,
    //      and exit(-1) if running doesn't hit 0.

    nanosleep(&tsExpected, NULL); //&tsElapsed);
    done = true;
    elapsedMillis = chrono::duration_cast<chrono::milliseconds>(chrono::high_resolution_clock::now() - startTime).count();
    long elapsedMillisNapping = 0;
    while (running.load() > 0 && elapsedMillisNapping < 200) { // nap for up to 200ms
        nanosleep(&tsNap, NULL); //&tsElapsed);
        elapsedMillisNapping = chrono::duration_cast<chrono::milliseconds>(chrono::high_resolution_clock::now() - startTime).count() - elapsedMillis;
    }
    elapsedMillis += elapsedMillisNapping;
#if 1
    if (running.load() > 0) {
        cout<<endl;
        COUTATOMIC("Validation FAILURE: "<<running.load()<<" non-terminating thread(s)"<<endl);
        cout<<endl;
        ds->prov.debugPrint();
        cout<<"ops="<<ds->successful->getTotal()<<endl;
        const int tidForReading = 0;
        cout<<"arrayTotal/K="<<(ds->getTotal(tidForReading)/KCAS_MAXK)<<endl;
        exit(-1);
    }
#else
    while (running.load() > 0) {}
#endif
//    // join all threads
//    for (int i=0;i<TOTAL_THREADS;++i) {
//        if (pthread_join(*(threads[i]), NULL)) {
//            cerr<<"ERROR: could not join thread"<<endl;
//            exit(-1);
//        }
//    }

    COUTATOMIC((elapsedMillis/1000.)<<"s"<<endl);
    
//    memoryFootprintAfter = getCurrentRSS();
//
//    struct rusage rusage;
//    getrusage( RUSAGE_SELF, &rusage );
//    memoryFootprintPeak = (size_t)(rusage.ru_maxrss * 1024L);
//
//    //memoryFootprintPeak = getPeakRSS();
    papi_print_counters(ds->totalOps->getTotal());
    
    for (int i=0;i<TOTAL_THREADS;++i) {
        delete threads[i];
    }
}

#define PRINTI(name) { cout<<(#name)<<"="<<name<<endl; }
#define PRINTS(name) { cout<<(#name)<<"="<<name<<endl; }

template <class RecManager>
void printOutput() {
    const int tid = 0;
    
    long long successfulOps = ds->successful->getTotal();
    long long totalOps = ds->totalOps->getTotal();
    
    long long sumOfEntries = ds->getTotal(tid);
    long long scaled = sumOfEntries/KCAS_MAXK;

    cout<<"Validation: "<<successfulOps<<" (#ops) ==? "<<scaled<<" (scaled total): ";
    cout<<((successfulOps == scaled) ? "OK." : "FAILED.")<<endl;
    cout<<endl;

    //cout<<"sum of entries : "<<sumOfEntries<<endl;

    cout<<"completed ops       : "<<totalOps<<endl;
    cout<<"throughput           : "<<(long long)(totalOps * 1000. / elapsedMillis)<<endl;
    cout<<"    incl. queries    : "<<(long long)(totalOps * 1000. / elapsedMillis)<<endl;
    cout<<"elapsed milliseconds : "<<elapsedMillis<<endl;
    cout<<endl;
    
    ds->prov.debugPrint();

#ifdef RECORD_HISTOGRAM
    cout<<endl;
    cout<<"Histogram"<<endl;
    const int numBuckets = 100;
    int buckets[numBuckets];
    int sumHistogram = 0;
    for (int i=0;i<numBuckets;++i) buckets[i] = 0;
    for (int i=0;i<MAXKEY;++i) {
        buckets[i/(MAXKEY/numBuckets)] += histogram[i];
        sumHistogram += histogram[i];
//        if (histogram[i] > 0) cout<<"histogram["<<i<<"]="<<histogram[i]<<endl;
    }
    cout<<"histogram sum = "<<sumHistogram<<" divided by 2 = "<<(sumHistogram / 2)<<endl;
    for (int i=0;i<numBuckets;++i) {
        if (buckets[i] > 0) {
            cout<<i<<","<<buckets[i]<<endl;
        }
    }
#endif
    
    COUTATOMIC("memory footprint before            : "<<0<<endl); //memoryFootprintBefore<<endl);
    COUTATOMIC("memory footprint after             : "<<0<<endl); //memoryFootprintAfter<<endl);
    COUTATOMIC("memory footprint peak non-adjusted : "<<memoryFootprintPeak<<endl);
    COUTATOMIC("memory footprint peak adjusted     : "<<memoryFootprintPeak<<endl); //(memoryFootprintPeak-memoryFootprintBefore)<<endl);
    
    if (successfulOps != scaled) {
        cout<<"ERROR: validation failed."<<endl;
        exit(-1);
    }
    
}

int main(int argc, char** argv) {
    RQ_THREADS = 0;
    MILLIS_TO_RUN = -1;
    for (int i=1;i<argc;++i) {
        if (strcmp(argv[i], "-k") == 0) {
            MAXKEY = atoi(argv[++i]);
        } else if (strcmp(argv[i], "-n") == 0) {
            TOTAL_THREADS = atoi(argv[++i]);
        } else if (strcmp(argv[i], "-t") == 0) {
            MILLIS_TO_RUN = atoi(argv[++i]);
        } else if (strcmp(argv[i], "-bind") == 0) {
            binding_parseCustom(string(argv[++i]));
        } else {
            cout<<"bad arguments"<<endl;
            exit(1);
        }
    }
    
    PRINTI(KCAS_MAXK);
    PRINTI(KCAS_MAXTHREADS);
    PRINTI(MILLIS_TO_RUN);
    PRINTI(MAXKEY);
    PRINTI(TOTAL_THREADS);
#ifdef WIDTH1_SEQ
    PRINTI(WIDTH1_SEQ);
#endif
//    PRINTI(THREAD_BINDING);
    
#ifdef DELAY_CYCLES
    PRINTI(DELAY_CYCLES);
#else
    cout<<"DELAY_CYCLES=undefined"<<endl;
#endif

    binding_configurePolicy(TOTAL_THREADS, LOGICAL_PROCESSORS);

    histogram = new int[MAXKEY];
    for (int i=0;i<MAXKEY;++i) histogram[i] = 0;
    ds = new dataStructure<RecManagerType>(TOTAL_THREADS, MAXKEY);

    trial<RecManagerType>();
    printOutput<RecManagerType>();
    
//    for (int i=0;i<MAXKEY;++i) {
//        cout<<" "<<ds->data[i];
//    }
//    cout<<endl;
    
    delete ds;
    delete[] histogram;
    
    return 0;
}
